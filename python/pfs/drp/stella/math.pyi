from typing import overload, Optional, Tuple, Union
import numpy as np
from lsst.afw.math import (
    PolynomialFunction1D,
    BasePolynomialFunction2D,
    PolynomialFunction2D,
    Chebyshev1Function2D,
)
from lsst.geom import Box2D, Point2D, AffineTransform

class NormalizedPolynomial1D(PolynomialFunction1D):
    @overload
    def __init__(self, order: int, min: float = -1.0, max: float = 1.0): ...
    @overload
    def __init__(self, params: np.ndarray, min: float = -1.0, max: float = 1.0): ...
    @overload
    def __call__(self, x: float) -> float: ...
    @overload
    def __call__(self, x: np.ndarray) -> np.ndarray: ...
    def clone(self) -> "NormalizedPolynomial1D": ...
    def getOrder(self) -> int: ...
    def getDFuncDParameters(self, x: float) -> np.ndarray: ...
    def calculateDesignMatrix(self, x: np.ndarray) -> np.ndarray: ...
    def getMin(self) -> float: ...
    def getMax(self) -> float: ...

class NormalizedPolynomial2D(BasePolynomialFunction2D):
    @overload
    def __init__(self, order: int, range: Box2D = Box2D(Point2D(-1, -1), Point2D(1, 1))): ...
    @overload
    def __init__(self, params: np.ndarray, range: Box2D = Box2D(Point2D(-1, -1), Point2D(1, 1))): ...
    @overload
    def __call__(self, x: float, y: float) -> float: ...
    @overload
    def __call__(self, x: np.ndarray, y: np.ndarray) -> np.ndarray: ...
    def clone(self) -> "NormalizedPolynomial2D": ...
    def getOrder(self) -> int: ...
    def getDFuncDParameters(self, x: float, y:float) -> np.ndarray: ...
    def calculateDesignMatrix(self, x: np.ndarray, y: np.ndarray) -> np.ndarray: ...
    def getXYRange(self) -> Box2D: ...


class PolynomialFunctionND:
    @overload
    def __init__(self, dims: int, order: int): ...
    @overload
    def __init__(self, dims: int, params: np.ndarray): ...
    def getNParameters(self) -> int: ...
    def getParameter(self, index: int) -> float: ...
    def clone(self) -> "PolynomialFunctionND": ...
    def getDimensions(self) -> int: ...
    def getParameters(self) -> np.ndarray: ...
    def getOrder(self) -> int: ...
    @staticmethod
    def nParametersFromOrder(dims: int, order: int) -> int: ...
    @staticmethod
    def orderFromNParameters(dims: int, nParameters: int) -> int: ...
    @staticmethod
    def getExponents(dims: int, order: int) -> np.ndarray: ...
    def __call__(self, x: np.ndarray) -> float: ...
    def getDFuncDParameters(self, x: np.ndarray) -> np.ndarray: ...
    def addDimension(self) -> np.ndarray: ...


class NormalizedPolynomialND(PolynomialFunctionND):
    @overload
    def __init__(self, order: int, min: np.ndarray, max: np.ndarray, newNorm: bool = True): ...
    @overload
    def __init__(self, params: np.ndarray, min: np.ndarray, max: np.ndarray, newNorm: bool = True): ...
    def clone(self) -> "NormalizedPolynomialND": ...
    def getNewNorm(self) -> bool: ...
    def getMin(self) -> np.ndarray: ...
    def getMax(self) -> np.ndarray: ...
    def normalize(self, x: np.ndarray) -> np.ndarray: ...


def evaluatePolynomial(
    poly: Union[Chebyshev1Function2D, PolynomialFunction2D, NormalizedPolynomial2D],
    x: np.ndarray,
    y: np.ndarray,
) -> np.ndarray: ...
def evaluateAffineTransform(
    transform: AffineTransform, x: np.ndarray, y: np.ndarray
) -> Tuple[np.ndarray, np.ndarray]: ...
def solveLeastSquaresDesign(
    design: np.ndarray,
    meas: np.ndarray,
    err: np.ndarray,
    threshold: float = 1.0e-6,
    forced: Optional[np.ndarray] = None,
    params: Optional[np.ndarray] = None,
) -> np.ndarray: ...
@overload
def calculateMedian(values: np.ndarray, mask: np.ndarray) -> float: ...
@overload
def calculateMedian(values: np.ndarray) -> float: ...
@overload
def calculateQuartiles(values: np.ndarray, mask: np.ndarray) -> Tuple[float, float, float]: ...
@overload
def calculateQuartiles(values: np.ndarray) -> Tuple[float, float, float]: ...
