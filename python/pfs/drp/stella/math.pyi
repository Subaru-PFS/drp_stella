from typing import overload, Tuple, Union
import numpy as np
from lsst.afw.math import (
    PolynomialFunction1D,
    BasePolynomialFunction2D,
    PolynomialFunction2D,
    Chebyshev1Function2D,
)
from lsst.geom import Box2D, Point2D, AffineTransform

class NormalizedPolynomial1D(PolynomialFunction1D):
    @overload
    def __init__(self, order: int, min: float = -1.0, max: float = 1.0): ...
    @overload
    def __init__(self, params: np.ndarray, min: float = -1.0, max: float = 1.0): ...
    @overload
    def __call__(self, x: float) -> float: ...
    @overload
    def __call__(self, x: np.ndarray) -> np.ndarray: ...
    def clone(self) -> "NormalizedPolynomial1D": ...
    def getOrder(self) -> int: ...
    def getDFuncDParameters(self, x: float) -> np.ndarray: ...
    def getMin(self) -> float: ...
    def getMax(self) -> float: ...
    # The following are inherited
    def getNParameters(self) -> int: ...
    def getParameters(self) -> np.ndarray: ...
    def getParameter(self, index: int) -> float: ...
    def isLinearCombination(self) -> bool: ...
    def setParameter(self, index: int, value: float): ...
    def setParameters(self, parameters: np.ndarray): ...
    def toString(self) -> str: ...

class NormalizedPolynomial2D(BasePolynomialFunction2D):
    @overload
    def __init__(self, order: int, range: Box2D = Box2D(Point2D(-1, -1), Point2D(1, 1))): ...
    @overload
    def __init__(self, params: np.ndarray, range: Box2D = Box2D(Point2D(-1, -1), Point2D(1, 1))): ...
    @overload
    def __call__(self, x: float, y: float) -> float: ...
    @overload
    def __call__(self, x: np.ndarray, y: np.ndarray) -> np.ndarray: ...
    def clone(self) -> "NormalizedPolynomial2D": ...
    def getOrder(self) -> int: ...
    def getDFuncDParameters(self, x: float, y: float) -> np.ndarray: ...
    def getXYRange(self) -> Box2D: ...
    # The following are inherited
    def getNParameters(self) -> int: ...
    def getParameters(self) -> np.ndarray: ...
    def getParameter(self, index: int) -> float: ...
    def isLinearCombination(self) -> bool: ...
    def setParameter(self, index: int, value: float): ...
    def setParameters(self, parameters: np.ndarray): ...
    def toString(self) -> str: ...
    @staticmethod
    def nParametersFromOrder(order: int) -> int: ...
    @staticmethod
    def orderFromNParameters(nParameters: int) -> int: ...

def calculateQuartiles(values: np.ndarray, masks: np.ndarray) -> Tuple[float, float, float]: ...
def evaluatePolynomial(
    poly: Union[Chebyshev1Function2D, PolynomialFunction2D, NormalizedPolynomial2D],
    x: np.ndarray,
    y: np.ndarray,
) -> np.ndarray: ...
def evaluateAffineTransform(
    transform: AffineTransform, x: np.ndarray, y: np.ndarray
) -> Tuple[np.ndarray, np.ndarray]: ...
def solveLeastSquaresDesign(
    design: np.ndarray, meas: np.ndarray, err: np.ndarray, threshold: float = 1.0e-6
) -> np.ndarray: ...
@overload
def calculateMedian(values: np.ndarray, mask: np.ndarray) -> float: ...
@overload
def calculateMedian(values: np.ndarray) -> float: ...
@overload
def calculateQuartiles(values: np.ndarray, mask: np.ndarray) -> Tuple[float, float, float]: ...
@overload
def calculateQuartiles(values: np.ndarray) -> Tuple[float, float, float]: ...
